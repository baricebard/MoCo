# 比較運算子 
大小的比較  
- 大於，小於：`a > b`，`a < b`
- 大於，小於，等於：`a >= b`，`a <= b`
- 等於：`a == b`，請注意雙等號 `==` 表示相等測試，而單一等號 `a = b` 表示賦值
- 不等於：在數學中表示為 $\neq$≠，但在 JavaScript 中寫為 `a != b`

## 結果輸出為布林值 
- true，表示 "真"、"是"、"正確"、"成立" 或 "事實"
- false，表示 "假"、"不是"、"錯誤"、"不成立" 或 "不是事實"  
``` JavaScript
alert( 2 > 1 );  // true (成立)
alert( 2 == 1 ); // false (錯)
alert( 2 != 1 ); // true (成立)
``` 
結果可放入變數  
``` JavaScript
let result = 5 > 4; // 把比較結果給 result 變數
alert( result ); // true
``` 
## 字串的比較
字串是逐個字母進行比較的，比較時使用 unicode 編碼比較  

字元轉編碼，字元碼  
``` JavaScript
alert('A'.charCodeAt(0))
alert('Hello'.charCodeAt(1))
alert('好'.charCodeAt(0))
``` 
字元碼轉字元  
``` JavaScript
alert(String.fromCharCode(65))
alert(String.fromCharCode(101))
alert(String.fromCharCode(22909))
```
比較兩個字串的演算法很簡單：  
1. 比較兩個字串的第一個字元  
2. 如果第一個字串的第一個字元大於（或小於）另一個字串的第一個字元，則第一個字串大於（或小於）第二個字串，結束。  
3. 否則，如果兩個字串的第一個字元相同，則以相同的方式比較第二個字元。
4. 重複直到任一字串結束。
5. 如果兩個字串的長度相同，則它們相等。否則，較長的字串更大。

## 不同資料型別的比較  
字串和任何數值比較時，會先將字串轉成數值，然後再比較  
``` JavaScript
alert( '2' > 1 ); // true, 先把字串 '2' 轉換為數值 2
alert( '01' == 1 ); // true, 先把字串 '01' 轉換為數值 1
```

布林值和數值比較時，`true` 轉換為 `1`，`false` 轉換為 `0`  
``` JavaScript
alert( true == 1 ); // true
alert( false == 0 ); // true
```
一個恐怖的結果
``` JavaScript
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true
```
為什麼？因為 Boolean() 函數用的是另一套規則。

## 嚴格模式的相等  

常規的相等性檢查 `==` 無法區分 `0` 和 `false`：  
``` JavaScript
alert( 0 == false ); // true
```
空字串的比較也有問題
``` JavaScript
alert( '' == false ); // true
```
原因：不同資料型別的比較，會先轉成數值。空字串 `''` 和 `false` 都會先轉換為 `0`  

如果我們想區分 `0` 和 `false`，該怎麼辦？  
使用嚴格相等運算子 `===` 檢查相等性，這個比較不會進行型別轉換  
``` JavaScript
alert( 0 === false ); // false, 因為型別不同
```

"嚴格模式不相等" 運算子 `!==` 是類似於 `!=` 不相等的比較，但不進行型別轉換  

## `null` 和 `undefined` 比較  
當 `null` 或 `undefined` 與其他型別進行比較時，也會出現要思考一下的結果  
互相比較時
``` JavaScript
alert( null == undefined ); // true
alert( null === undefined ); // false
```


## 其他比較 `< > <= >=` 
不同型別比較時，會先轉換成數值  
`null`/`undefined` 轉換為數值：`null` 變成 `0`，而 `undefined` 變成 `NaN`  

## `null` 和 `0`  
`null` 和 `0` 的比較  
``` JavaScript
lert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```
(1)、(2)、(3) 比較的結果不同， 很奇怪  
這是因為相等性檢查 `==` 和比較運算子 `> < >= <=` 的工作方式不同  
比較會轉換 `null` 為數值，並將其視為 `0`
- 所以 (3) `null >= 0` 為 `true`，而 (1) `null > 0` 為 `false`
- 而相等性檢查 `==` 在 `null` 和 `undefined` 的比較運算時定義為：在不進行任何轉換的情況下，它們彼此相等，且不等於任何其他值。這就是為什麼 (2) 為假。  

## `undefined` 不能比較
`undefined` 不應與其他值進行比較：  
``` JavaScript
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```  
- (1) 和 (2) 的比較結果是 `false`， 因為 `undefined` 被轉換為 `NaN` ，而 `NaN` 是一種特別的數值，所有比較的結果都會是 `false`  
- (3) 的相等性檢查結果是 `false`，因為 `undefined` 只和 `null`、`undefined` 相等，其他的比較都是 `flase`  

## 如何避免問題  
隨著使用 JavaScript 開發的時間增加，你會遇到越來越多的這種問題  
所以  
- `undefined` 和 `null` 除了嚴格模式相等之外，對待任何比較都要格外謹慎  
- 如果變數的值可能是 `null` 或 `undefined`，那就進行額外的檢查，不要用比較運算子直接比較

## 總結  
- 比較運算子傳回布林值
- 字串按照 uncode 的字元碼逐個字母進行比較
- 當比較不同資料型別的值時，它們會先轉換為數值（嚴格模式相等性檢查不會轉換）
- 值 `null` 和 `undefined`之間的 `==` 比較相等，和其他值比較結果都是 `false`
- 使用類似 `>` 的比較運算子來比較 `null` 和 `undefined` 時，要先分別對 `null` 和 `undefined` 進行檢查  

## 任務
這些表達式的結果是什麼？
```javascript
5 > 4
"apple" > "pineapple"
"2" > "12"
undefined == null
undefined === null
null == "\n0\n"
null === +"\n0\n"
```
<detail>
<summary>參考答案</summary>
```javascript
5 > 4 → true
"apple" > "pineapple" → false   // unicode 比較，因此為 flase。"a" 小於 "p"
"2" > "12" → true               // 第一個字元 "2" 大於第一個字元 "1"
undefined == null → true        // undefined 和 null 比較為 treu
undefined === null → false      // 嚴格模式的相等。如果雙方類型不同，則傳回  false
null == "\n0\n" → false         // null 僅等於 undefined
null === +"\n0\n" → false       // 不同類型的嚴格相等比較
```

