# Fetch

JavaScript 可以向伺服器發送網路請求，並在需要時載入新資訊。  

例如，我們可以使用網路請求來：  

- 提交訂單  
- 載入用戶訊息
- 從伺服器接收最新更新  
- 其他

無需重新加載頁面  

## AJAX Asynchronous JavaScript And XML 
AJAX 是一個統稱，用來指稱 JavaScript 啟動的網路請求。
但是不一定要使用 XML。 XML 這個術語源自於過去，所以才保留了 XML 這個字

發送網路請求並從伺服器獲取資訊有多種方法  

這種 `fetch()` 方法既現代又靈活，所以我們就從它開始。雖然舊版瀏覽器不支援它（雖然可以透過 polyfill 實現），但現代瀏覽器對它的支援非常好。

基本語法如下：
```JavaScript
let promise = fetch(url, [options])
```

- url 要存取的網址  
- options 可選參數：方法、標頭等  

如果沒有 options，這只是一個簡單的 GET 請求  

請求時  
Step1. 瀏覽器發起請求，並傳回一個 Promise  
Step2. 呼叫的程式碼使用這個 Promise 取得結果  


取得回覆通常是一個兩階段的過程  
首先，promise 這個物件在伺服器回應時，由傳回的值 fetch 會解析為內建 [Response](https://fetch.spec.whatwg.org/#response-class) 類別的物件  

在這個階段，應該檢查 HTTP 狀態，看看是否成功，然後檢查 Header，但還沒有內文。

如果無法發出 HTTP 請求（例如網路問題）或網站不存在，則 Promise 將被拒絕 fetch。異常的 HTTP 狀態碼（例如 404 或 500）不會導致錯誤。  

我們可以在回應屬性中看到HTTP狀態：  

- status – HTTP 狀態碼，例如 200。
- ok – 布林值，true表示 HTTP 狀態碼是否為 200-299。

```JavaScript
let response = await fetch(url);

if (response.ok) { // if HTTP-status is 200-299
  // get the response body (the method explained below)
  let json = await response.json();
} else {
  alert("HTTP-Error: " + response.status);
}
```

然後，使用額外的方法來呼叫，取得回應內文  

`Response` 提供多種基於 `Promise` 的方法來存取各種格式的主體：

- `response.text()` 讀取回應並以文字形式返回，
- `response.json()` 將回應解析為 JSON 格式，
- `response.formData()` 將回應作為 FormData 物件傳回
- `response.blob()` 將回應以 `Blob`（具有特定類型的二進位資料）的形式傳回
- `response.arrayBuffer()` 將回應以 `ArrayBuffer`（二進位資料的底層表示形式）的形式傳回
- `response.body` 它是一個 `ReadableStream` 對象，可逐塊讀取主體

例如，從 GitHub 取得包含最新提交資訊的 JSON 物件：  

```JavaScript
let url = 'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits';
let response = await fetch(url);

let commits = await response.json(); // read response body and parse as JSON

alert(commits[0].author.login);
```

或者，不用 `--promise` `await`，直接使用純 `Promise` 語法：  

```JavaScript
fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
  .then(response => response.json())
  .then(commits => alert(commits[0].author.login));

```

若要取得回應文本，`await response.text()` 使用 `.json()`  

```JavaScript
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

let text = await response.text(); // read response body as text

alert(text.slice(0, 80) + '...');
```
展示二進制格式的讀取功能，我們來獲取並顯示 “fetch”規範的徽標圖像（有關操作的詳細信息，請參閱BlobBlob章節）：

顯示圖片的範例  
```JavaScript
let url = 'https://resources.whatwg.org/logo-fetch.svg'
let response = await fetch(url);
//let response = await fetch('/article/fetch/logo-fetch.svg');

let blob = await response.blob(); // download as Blob object

// create <img> for it
let img = document.createElement('img');
img.style = 'position:fixed;top:10px;left:10px;width:100px';
document.body.append(img);

// show it
img.src = URL.createObjectURL(blob);

setTimeout(() => { // hide after three seconds
  img.remove();
  URL.revokeObjectURL(img.src);
}, 3000);
```

### 提醒  

我們只能選擇一種解析 body 的方法  

如果我們已經收到了回應 `response.text()`，那麼將 `response.json()`無法運作，因為內文已被處理  

```JavaScript
let text = await response.text(); // response body consumed
let parsed = await response.json(); // fails (already consumed)
```

## Response headers  
Response header 類似 Map 的 headers 物件    

雖然不是嚴格意義上的 Map，但提供了類似的方法，可以透過名稱取得各個標題或遍歷：  

```JavaScript
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

// get one header
alert(response.headers.get('Content-Type')); // application/json; charset=utf-8

// iterate over all headers
for (let [key, value] of response.headers) {
  alert(`${key} = ${value}`);
}
```

## Request headers

要在請求中設定請求頭 `fetch`，我們可以使用 ` headers--headers` 選項。
包含一個帶有傳出請求頭的對象，如下所示：  

```JavaScript
let response = fetch(protectedUrl, {
  headers: {
    Authentication: 'secret'
  }
});
```

禁止設定的 HTTP 標頭清單

- Accept-Charset，Accept-Encoding
- Access-Control-Request-Headers
- Access-Control-Request-Method
- Connection
- Content-Length
- Cookie，Cookie2
- Date
- DNT
- Expect
- Host
- Keep-Alive
- Origin
- Referer
- TE
- Trailer
- Transfer-Encoding
- Upgrade
- Via
- Proxy-*
- Sec-*

這些標頭確保 HTTP 協定的正確性和安全性，因此它們完全由瀏覽器控制。

## POST 請求  

要發出 `POST` 請求，或使用其他方法發出請求，我們需要使用 `fetch` 選項：

- `method`– HTTP 方法，例如`POST`，
- `body` 請求正文，可以是以下之一：
    - 字串（例如 JSON 編碼的字串），
    - `FormData` 對象，以下列方式提交資料 `multipart/form-data` 
    - `Blob`/`BufferSource` 發送二進位數據
    - `URLSearchParams`，用於提交編碼數據`x-www-form-urlencoded`，很少使用。

JSON 格式應用最廣。

例如，以下程式碼 user 以 JSON 格式提交物件：

```JavaScript
let user = {
  name: 'John',
  surname: 'Smith'
};

let response = await fetch('/article/fetch/post/user', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json;charset=utf-8'
  },
  body: JSON.stringify(user)
});

let result = await response.json();
alert(result.message);
```
如果請求 `body` 是字串，則標頭預設 `Content-Type` 是 `text/plain;charset=UTF-8`。  

但是，由於我們要發送 JSON 數據，所以我們使用 `headers` 選項 `application/jsonContent-Type` 來發送 JSON 編碼的數據，才是正確的。  

## 傳送圖片  

`fetch` 也可以使用 `Blob` 或 `BufferSource` 物件提交二進位資料。

在以下的例子中，我們可以將滑鼠懸停在某個 <canvas> 區域上進行繪製。
點擊「提交」按鈕會將圖像傳送到伺服器：

```JavaScript
<body style="margin:0">
  <canvas id="canvasElem" width="100" height="80" style="border:1px solid"></canvas>

  <input type="button" value="Submit" onclick="submit()">

  <script>
    canvasElem.onmousemove = function(e) {
      let ctx = canvasElem.getContext('2d');
      ctx.lineTo(e.clientX, e.clientY);
      ctx.stroke();
    };

    async function submit() {
      let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));
      let response = await fetch('/article/fetch/post/image', {
        method: 'POST',
        body: blob
      });

      // the server responds with confirmation and the image size
      let result = await response.json();
      alert(result.message);
    }

  </script>
</body>
```
這裡沒有手動設定 Content-Type 標頭，因為 Blob 物件具有內建類型（由 toBlob 生成 image/png）。    
對於 Blob 對象，該類型成為的值 Content-Type  

submit() 可以這樣重寫：async/await

```JavaScript
function submit() {
  canvasElem.toBlob(function(blob) {
    fetch('/article/fetch/post/image', {
      method: 'POST',
      body: blob
    })
      .then(response => response.json())
      .then(result => alert(JSON.stringify(result, null, 2)))
  }, 'image/png');
}
```

## 總結

一個典型的獲取請求包含兩個 `await` 呼叫：

```JavaScript
let response = await fetch(url, options); // resolves with response headers
let result = await response.json(); // read body as json
```

或者，不帶 `await`：

```JavaScript
fetch(url, options)
  .then(response => response.json())
  .then(result => /* process result */)
```

響應屬性：

- response.status – 回應的HTTP代碼
- response.ok – `true` 如果狀態為 200-299
- response.headers – 類似 Map 的對象，包含 HTTP 標頭

取得響應體的方法：  

- response.text() – 以文字形式回傳回應
- response.json() – 將回應解析為 JSON 對象
- response.formData() – 將回應作為FormData物件返回
- response.blob() – 將回應以 Blob（具有特定類型的二進位資料）的形式傳回
- response.arrayBuffer() – 將回應以 ArrayBuffer（底層二進位資料）的形式傳回

目前可用的取得選項：

- method – HTTP 方法
- headers – 一個包含請求頭的物件（並非允許任何請求頭），
- body – 要傳送的資料（請求內文），可以是、`string`、`FormData`或 `BufferSource` 物件，`Blob` 或 `UrlSearchParams`

## 任務  

從 GitHub 取得用戶
建立一個非同步函數getUsers(names)，該函數接收一個 GitHub 登入名稱數組，從 GitHub 取得用戶，並傳回一個 GitHub 用戶陣列。

包含給定使用者資訊的 GitHub URLUSERNAME為：https://api.github.com/users/USERNAME。

- fetch 每個用戶只能發出一個請求
- 請求之間不應該互相等待，這樣資料才能盡快到達
- 如果任何請求失敗，或不存在這樣的用戶，則該函數應傳回 null 結果陣列。

提示：
要取得用戶，需要：fetch('https://api.github.com/users/USERNAME')。

如果回應有狀態200，則呼叫.json()讀取 JS 物件。

如果 fetch 失敗，或回應狀態不是 200，就直接在結果陣列中傳回 `null`

<details>
    <summary>參考答案</summary>

```JavaScript   
    async function getUsers(names) {
        let jobs = [];

        for(let name of names) {
            let job = fetch('https://api.github.com/users/${name}').then(
                successResponse => {
                    if (successResponse.status != 200) {
                        return null;
                    } else {
                        return successResponse.json();
                    }
                },
                failResponse => {
                    return null;
                }
            );
            jobs.push(job);
        }

        let results = await Promise.all(jobs);

        return results;
    }
```

請注意：`.then` 呼叫直接附加到 `fetch`，因此當我們收到回應時，它不會等待其他獲取操作，而是 `.json()` 立即開始讀取。

如果使用 ` await Promise.all(names.map(name => fetch(...)))fetch()` 並呼叫 `.json()` 結果，那麼它會等待所有 `fetch` 請求都回應完畢。透過 `.json()` 直接在每個 `fetch()` 請求中加入 `get()` fetch 語句，可以確保每個 `fetch` 請求都能立即開始以 JSON 格式讀取數據，而無需相互等待。

這就好比我們主要使用 `async/await` 一樣，底層 Promise API 仍然很有用。
</details>

