# Fetch：下載進度  

`fetch` 方法可以追蹤下載進度。  

目前 `fetch` 無法追蹤上傳進度。但可以使用 `XMLHttpRequest` 做到。  

追蹤下載進度可以使用 `response.body` 屬性。它是`ReadableStream` 一個特殊對象，可以逐塊提供下載內容。    

和 `response.text()` 與 `response.json()` 等其他方法不同，`response.body` 可以完全控制閱讀過程，可以隨時計算消耗了多少。  

以下是讀取回應的 `response.body` 程式碼：  
```JavaScript
// 取代 response.json()
const reader = response.body.getReader();

// infinite loop while the body is downloading
while(true) {
  // done is true for the last chunk
  // value is Uint8Array of the chunk bytes
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  console.log(`Received ${value.length} bytes`)
}
```  

呼叫 `await reader.read()` 的結果是一個包含兩個屬性的物件：

- done – 當閱讀完成時 true，否則 false  
- value – 一個類型化的位元組陣列：Uint8Array

在循環中接收回應區塊，直到載入完成，即：直到 `done` 變成`true`。  

為了記錄進度，只需要將接收到的每個片段的 `value` 長度加入計數器。

以下是一個完整的運行範例，它會獲取回應並在控制台中記錄進度，更多解釋將在後面提供：  

```JavaScript
// Step 1: start the fetch and obtain a reader
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100');

const reader = response.body.getReader();

// Step 2: get total length
const contentLength = +response.headers.get('Content-Length');

// Step 3: read the data
let receivedLength = 0; // received that many bytes at the moment
let chunks = []; // array of received binary chunks (comprises the body)
while(true) {
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  chunks.push(value);
  receivedLength += value.length;

  console.log(`Received ${receivedLength} of ${contentLength}`)
}

// Step 4: concatenate chunks into single Uint8Array
let chunksAll = new Uint8Array(receivedLength); // (4.1)
let position = 0;
for(let chunk of chunks) {
  chunksAll.set(chunk, position); // (4.2)
  position += chunk.length;
}

// Step 5: decode into a string
let result = new TextDecoder("utf-8").decode(chunksAll);

// We're done!
let commits = JSON.parse(result);
alert(commits[0].author.login);
```  

每一步的說明：

1. `fetch` 照常執行操作，但不調用 `response.json()`，而是取得一個流讀取器 `response.body.getReader()`。
請注意，不能同時使用這兩種方法來讀取同一個回應：要麼使用讀取器方法，要麼使用回應方法來取得結果。  

2. 在讀取之前，可以從頭部資訊中確定完整的回應長度`Content-Length`。
對於跨域請求，這個資訊可能不存在。而且，伺服器設定此值的操作不是必需的，但通常是存在的  

3. 一直呼叫 `await reader.read()` 直到完成為止。
將響應塊收集到 `chunks` 陣列中。  

4. 最後，我們得到 chunks 位元組塊陣列 Uint8Array。 需要將它們連接成一個單一的結果。遺憾的是，沒有一個方法可以一次完成這些連接，所以需要寫一些程式碼來實現：
    1. 建立 `chunksAll = new Uint8Array(receivedLength)` 一個長度相同的同類型數組
    2. 然後使用 `.set(chunk, position)` 方法將它們一個接一個地複製到其中
5. 現在已經得到了結果 `chunksAll`。不過它是一個位元組陣列，而不是字串。

    要建立字串，我們需要解析這些位元組。內建的TextDecoder正是用來做這件事的。然後JSON.parse，如有必要，我們可以將其轉換為字串。    

    如果我們需要的是二進位內容而不是字串呢？那就更簡單了。只需將步驟 4 和 5 替換為一行程式碼，該程式碼可以Blob從所有資料區塊中建立二進位檔案：
    ```JavaScript
    let blob = new Blob(chunks);
    ```  

最後，我們會得到結果（以字串或資料塊的形式，視情況而定），並在過程中追蹤進度。    

再次提醒，這並非用於顯示上傳進度（目前無法顯示fetch），而僅用於顯示下載進度。    

此外，如果大小未知，我們應該receivedLength在循環中檢查大小，並在達到某個限制時跳出循環，以防止chunks記憶體溢出。



