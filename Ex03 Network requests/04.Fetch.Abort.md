# fetch：中止  
取得：中止
我們知道，` fetchreturns` 回傳一個 Promise。而 JavaScript 通常沒有「中止」Promise 的概念。那麼，我們該如何取消一個正在進行的 Promise 呢fetch？例如，如果使用者在我們網站上的操作表明fetch不再需要該 Promise 了。

有一個專門用於此目的的內建物件：AbortController。它不僅可以用於中止fetch，還可以用於中止其他非同步任務。

使用方法非常簡單：

AbortController 對象
建立控制器：

let controller = new AbortController();
控制器是一個極為簡單的物件。

它只有一個方法abort()，
以及一個signal允許在其上設定事件監聽器的屬性。
何時abort()調用：

controller.signal發出"abort"事件。
controller.signal.aborted屬性變為true。
通常情況下，這個過程涉及兩個面向：

執行可取消操作的那個操作，它會設定一個監聽器controller.signal。
取消功能：它會controller.abort()在需要時撥打電話。
以下是完整的範例（尚未包含fetch）：

```JavaScript
let controller = new AbortController();
let signal = controller.signal;

// The party that performs a cancelable operation
// gets the "signal" object
// and sets the listener to trigger when controller.abort() is called
signal.addEventListener('abort', () => alert("abort!"));

// The other party, that cancels (at any point later):
controller.abort(); // abort!

// The event triggers and signal.aborted becomes true
alert(signal.aborted); // true
```

如我們所見，這只是在呼叫它時AbortController傳遞abort事件的一種方式。abort()

我們可以在自己的程式碼中實現相同的事件監聽功能，而無需使用該AbortController物件。

但真正有價值的是，它fetch知道如何與AbortController物件互動。它已經融入其中。

## 使用 fetch
若要取消操作fetch，請將signal屬性AbortController作為fetch選項傳遞：

```JavaScript
let controller = new AbortController();
fetch(url, {
  signal: controller.signal
});
```

方法fetch知道如何與之配合使用AbortController。它會監聽abort事件signal。  

若要中止操作，請呼叫controller.abort()：  

`controller.abort();`  

我們已經完成了：fetch從事件中取得事件signal並中止請求。  

當 fetch 操作中止時，其 Promise 會因錯誤而拒絕AbortError，因此我們應該處理它，例如在try..catch。

以下是完整的範例，其中程式 `fetch` 在 1 秒後中止：

```JavaScript
// abort in 1 second
let controller = new AbortController();
setTimeout(() => controller.abort(), 1000);

try {
  let response = await fetch('/article/fetch-abort/demo/hang', {
    signal: controller.signal
  });
} catch(err) {
  if (err.name == 'AbortError') { // handle abort()
    alert("Aborted!");
  } else {
    throw err;
  }
}
```

## AbortController 是可擴展的
AbortController具有可擴展性。它允許一次性取消多個資料獲取請求。  

以下是一個程式碼草圖，它並行取得多個urls數據，並使用單一控制器來中止所有操作：  

```JavaScript
let urls = [...]; // a list of urls to fetch in parallel

let controller = new AbortController();

// an array of fetch promises
let fetchJobs = urls.map(url => fetch(url, {
  signal: controller.signal
}));

let results = await Promise.all(fetchJobs);

// if controller.abort() is called from anywhere,
// it aborts all fetches
```

如果我們有自己的非同步任務，與 不同fetch，我們可以使用單一AbortController來停止這些任務以及獲取操作。    

abort我們只需要在任務中監聽它的事件即可：     

```JavaScript
let urls = [...];
let controller = new AbortController();

let ourJob = new Promise((resolve, reject) => { // our task
  ...
  controller.signal.addEventListener('abort', reject);
});

let fetchJobs = urls.map(url => fetch(url, { // fetches
  signal: controller.signal
}));

// Wait for fetches and our task in parallel
let results = await Promise.all([...fetchJobs, ourJob]);

// if controller.abort() is called from anywhere,
// it aborts all fetches and ourJob
```

## 總結
- AbortController是一個簡單的對象，當調用該方法時，它會abort在其signal屬性上產生一個事件（並且也會將其設為）。abort()signal.abortedtrue
- fetch它與之整合：我們將該signal屬性作為選項傳遞，然後fetch監聽它，因此可以中止fetch。
- 我們可以AbortController在程式碼中使用它。 「呼叫abort()」→「監聽abort事件」的互動簡單且通用。即使沒有它，我們也可以使用它fetch。
